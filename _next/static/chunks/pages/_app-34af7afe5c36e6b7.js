(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{1780:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(1212)}])},1212:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return Rs}});var o=n(5893),r=n(9008),a=n(7294),s=n(3935);var i=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var c=function(e){return!!e&&"function"===typeof e.then};var u=function(e,t){if(null!=e)return e;throw i(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class d{getValue(){throw i("BaseLoadable")}toPromise(){throw i("BaseLoadable")}valueMaybe(){throw i("BaseLoadable")}valueOrThrow(){throw i(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw i("BaseLoadable")}promiseOrThrow(){throw i(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw i("BaseLoadable")}errorOrThrow(){throw i(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw i("BaseLoadable")}}class f extends d{constructor(e){super(),l(this,"state","hasValue"),l(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return c(t)?m(t):g(t)?t:v(t)}catch(t){return c(t)?m(t.next((()=>this.map(e)))):y(t)}}}class h extends d{constructor(e){super(),l(this,"state","hasError"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class p extends d{constructor(e){super(),l(this,"state","loading"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return m(this.contents.then((t=>{const n=e(t);if(g(n)){const e=n;switch(e.state){case"hasValue":return e.contents;case"hasError":throw e.contents;case"loading":return e.contents}}return n})).catch((t=>{if(c(t))return t.then((()=>this.map(e).contents));throw t})))}}function v(e){return Object.freeze(new f(e))}function y(e){return Object.freeze(new h(e))}function m(e){return Object.freeze(new p(e))}function _(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?v(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?y(u(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):m(Promise.all(e.map((e=>e.contents))))}(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t])));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function g(e){return e instanceof d}const S={of:e=>c(e)?m(e):v(e),error:e=>y(e),all:_,isLoadable:g};var b={loadableWithValue:v,loadableWithError:y,loadableWithPromise:m,loadableLoading:function(){return Object.freeze(new p(new Promise((()=>{}))))},loadableAll:_,isLoadable:g,RecoilLoadable:S},w=b.loadableWithValue,T=b.loadableWithError,R=b.loadableWithPromise,A=b.loadableLoading,E=b.loadableAll,N=b.isLoadable,k=b.RecoilLoadable,V=Object.freeze({__proto__:null,loadableWithValue:w,loadableWithError:T,loadableWithPromise:R,loadableLoading:A,loadableAll:E,isLoadable:N,RecoilLoadable:k});var L,M=function(e,...t){0};const C=null!==(L=a.useMutableSource)&&void 0!==L?L:a.unstable_useMutableSource;var U={mutableSourceExists:function(){return C&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:C};const{mutableSourceExists:D}=U,B=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0).set("recoil_suppress_rerender_in_callback",!0);function x(e){var t;return!("recoil_early_rendering_2021"===e&&!D())&&(null!==(t=B.get(e))&&void 0!==t&&t)}x.setPass=e=>{B.set(e,!0)},x.setFail=e=>{B.set(e,!1)};var I=x;var O=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var P=function(e,t,{error:n}={}){return null};class z{constructor(e){l(this,"key",void 0),this.key=e}}class F extends z{}class j extends z{}var $={AbstractRecoilValue:z,RecoilState:F,RecoilValueReadOnly:j,isRecoilValue:function(e){return e instanceof F||e instanceof j}},W=$.AbstractRecoilValue,q=$.RecoilState,G=$.RecoilValueReadOnly,H=$.isRecoilValue,K=Object.freeze({__proto__:null,AbstractRecoilValue:W,RecoilState:q,RecoilValueReadOnly:G,isRecoilValue:H});class Z{}const J=new Z;class X extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const Q=new Map,Y=new Map;class ee extends Error{}const te=new Map;function ne(e){return te.get(e)}var oe={nodes:Q,recoilValues:Y,registerNode:function(e){if(Q.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}Q.set(e.key,e);const t=null==e.set?new K.RecoilValueReadOnly(e.key):new K.RecoilState(e.key);return Y.set(e.key,t),t},getNode:function(e){const t=Q.get(e);if(null==t)throw new ee(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return Q.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!I("recoil_memory_managament_2020"))return;const n=Q.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(Q.delete(e),null===(o=ne(e))||void 0===o||o(),te.delete(e))},setConfigDeletionHandler:function(e,t){I("recoil_memory_managament_2020")&&(void 0===t?te.delete(e):te.set(e,t))},getConfigDeletionHandler:ne,recoilValuesForKeys:function(e){return O(e,(e=>u(Y.get(e))))},NodeMissingError:ee,DefaultValue:Z,DEFAULT_VALUE:J,RecoilValueNotReady:X};var re={enqueueExecution:function(e,t){t()}};var ae,se=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},c=function(e){return function(){return e}},u=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),c=l(n,a);return g(t,d(i)|d(c),i===c?[e(t,n+5,o,r,a,s)]:i<c?[r,s]:[s,r])},w=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,s){if(t(a,this.key)){var c=o(this.value);return c===this.value?this:c===i?(--s.value,v):w(e,this)?(this.value=c,this):m(e,r,a,c)}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var c=function(e,t,n,o,r,a,s,c){for(var u=r.length,l=0;l<u;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--c.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++c.value,h(e,u,m(t,o,s,y),r))}(w(e,this),e,t,this.hash,this.children,o,a,s);return c===this.children?this:c.length>1?_(e,this.hash,c):c[0]}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},A=function(e,t,n,o,r,s,i){var c=this.mask,u=this.children,m=l(n,r),_=d(m),b=f(c,_),T=c&_,R=T?u[b]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,N=w(e,this),k=c,V=void 0;if(T&&y(A)){if(!(k&=~_))return v;if(u.length<=2&&((E=u[1^b])===v||1===E.type||2===E.type))return u[1^b];V=p(N,b,u)}else if(T||y(A))V=h(N,b,A,u);else{if(u.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,c=0;s;++c)1&s&&(a[c]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,c,u);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,c=new Array(r+1);s<t;)c[i++]=o[s++];for(c[t]=n;s<r;)c[++i]=o[s++];return c}(N,b,A,u)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var c=this.size,u=this.children,d=l(n,r),f=u[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=w(e,this),_=void 0;if(y(f)&&!y(p))++c,_=h(m,d,p,u);else if(!y(f)&&y(p)){if(--c<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,c=o.length;i<c;++i)if(i!==n){var u=o[i];u&&!y(u)&&(r[a++]=u,s|=1<<i)}return g(e,s,r)}(e,c,d,u);_=h(m,d,v,u)}else _=h(m,d,p,u);return m?(this.size=c,this.children=_,this):S(e,c,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var c=o();return c===i?v:(++s.value,m(e,r,a,c))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,c=0,u=i.length;c<u;++c){var h=i[c];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||u},v,0)},n.empty=n.make();var D=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return D(this)};var B=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return B(n,e,t,this)};var x=n.modify=function(e,t,n){return B(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return x(t,e,this)};var I=n.setHash=function(e,t,n,o){return B(c(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var O=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return O(e,t,this)};var P=c(i),z=n.removeHash=function(e,t,n){return B(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return j(this)};var $=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return $(this)};var W=n.mutate=function(e,t){var n=j(t);return e(n),$(n)};N.prototype.mutate=function(e){return W(e,this)};var q=function(e){return e&&G(e[0],e[1],e[2],e[3],e[4])},G=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return q(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return G(o.length,o,0,t,n);default:return q(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=q(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},X=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,X)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return Q(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var c=a[s++];c&&c.type&&(1===c.type?t=e(t,c.value,c.key):r.push(c.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(ae={exports:{}},ae.exports),ae.exports);class ie{constructor(e){l(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return ue(this)}toMap(){return new Map(this._map)}}class ce{constructor(e){if(l(this,"_hamt",se.empty.beginMutation()),e instanceof ce){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return ue(this)}toMap(){return new Map(this._hamt)}}function ue(e){return I("recoil_hamt_2020")?new ce(e):new ie(e)}var le=ue,de=Object.freeze({__proto__:null,persistentMap:le});var fe=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var he=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function pe(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:fe(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);u(r.get(e)).add(t)})),a){fe(a,e).forEach((e=>{if(!r.has(e))return;const n=u(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var ve={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),u(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:he(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:he(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=u(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&P("Tried to save dependencies to a discarded tree");const c=t.getGraph(n);if(pe(e,c),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){pe(e,t.getGraph(i.currentTree.version),c)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var u;const n=null===(u=i.nextTree)||void 0===u?void 0:u.version;if(void 0!==n){pe(e,t.getGraph(n),c)}}}};const{persistentMap:ye}=de,{graph:me}=ve;let _e=0;const ge=()=>_e++;function Se(){const e=ge();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:ye(),nonvalidatedAtoms:ye()}}var be={makeEmptyTreeState:Se,makeEmptyStoreState:function(){const e=Se();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,me()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:ge};var we=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var Te={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Re=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};class Ae{}var Ee={RetentionZone:Ae,retentionZone:function(){return new Ae}};const{setByAddingToSet:Ne}=Te,{getNode:ke,getNodeMaybe:Ve,recoilValuesForKeys:Le}=oe,{RetentionZone:Me}=Ee,Ce=Object.freeze(new Set);class Ue extends Error{}function De(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=ke(n),s=function(e,t,n){if(!I("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Me)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!I("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Me)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Be(e,t,n){return ke(n).peek(e,t)}function xe(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Ce;for(const t of e)o.has(t)||r.push(t)}return o}var Ie={getNodeLoadable:function(e,t,n){return De(e,t,n,"get"),ke(n).get(e,t)},peekNodeLoadable:Be,setNodeValue:function(e,t,n,o){const r=ke(n);if(null==r.set)throw new Ue(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return De(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Ve(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ne(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const s=e.getState(),i=e.getGraph(t.version),c=s.knownAtoms.has(n)?"atom":s.knownSelectors.has(n)?"selector":void 0,u=Re(xe(e,t,new Set([n])),(e=>e!==n));return{loadable:Be(e,t,n),isActive:s.knownAtoms.has(n)||s.knownSelectors.has(n),isSet:"selector"!==c&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:c,deps:Le(null!==(o=i.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:Le(u),components:O(null!==(r=null===(a=s.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:xe,initializeNodeIfNewToStore:De};const{getDownstreamNodes:Oe,getNodeLoadable:Pe,setNodeValue:ze}=Ie,{getNodeMaybe:Fe}=oe,{DefaultValue:je,RecoilValueNotReady:$e}=oe,{AbstractRecoilValue:We,RecoilState:qe,RecoilValueReadOnly:Ge,isRecoilValue:He}=K;function Ke(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=Pe(e,t,n);if("loading"===r.state)throw new $e(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=ze(e,t,o.key,a);for(const[e,n]of s.entries())Ze(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;Ze(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=Fe(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else P(`Unknown action ${n.type}`)}function Ze(e,t,n){"hasValue"===n.state&&n.contents instanceof je?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Je(e,t){e.replaceState((n=>{const o=Ye(n);for(const r of t)Ke(e,o,r);return et(e,o),o}))}function Xe(e,t){if(Qe.length){const n=Qe[Qe.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Je(e,[t])}const Qe=[];function Ye(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function et(e,t){const n=Oe(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=Fe(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function tt(e,t,n){Xe(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let nt=0;var ot={RecoilValueReadOnly:Ge,AbstractRecoilValue:We,RecoilState:qe,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&P("Tried to read from a discarded tree");const s=Pe(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:tt,setRecoilValueLoadable:function(e,t,n){if(n instanceof je)return tt(e,t,n);Xe(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){Xe(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){Xe(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=nt++,a=e.getState();if(a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),u(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),I("recoil_early_rendering_2021")){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):P(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:He,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof je?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return Qe.push(e),()=>{for(const[t,n]of e)Je(t,n);Qe.pop()!==e&&P("Incorrect order of batch popping")}},writeLoadableToTreeState:Ze,invalidateDownstreams:et,copyTreeState:Ye,invalidateDownstreams_FOR_TESTING:et};var rt=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:at}=Ie,{deleteNodeConfigIfPossible:st,getNode:it}=oe,{RetentionZone:ct}=Ee,ut=new Set;function lt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void P("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof ct)for(const e of ft(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return i(t),a;function i(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],i=new Set;for(;n.size>0;)c(u(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(i.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);i.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===it(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(ht(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&rt(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:ut){var h;a.has(t)||f.add(t)}f.size&&i(f)}}(e,r);for(const s of a)dt(e,o,s)}function dt(e,t,n){if(!I("recoil_memory_managament_2020"))return;at(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=ht(n);for(const c of r){var a;null===(a=o.retention.nodesRetainedByZone.get(c))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}st(n)}function ft(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:ut}function ht(e){const t=it(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof ct?[t]:t}function pt(e,t){if(!I("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):lt(e,new Set([t]))}(e,t)}var vt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!I("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?pt(e,t):r.set(t,a)},updateRetainCountToZero:pt,releaseScheduledRetainablesNow:function(e){if(!I("recoil_memory_managament_2020"))return;const t=e.getState();lt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var yt=function*(e){for(const t of e)for(const e of t)yield e};var mt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{unstable_batchedUpdates:_t}=s;var gt={unstable_batchedUpdates:_t};const{unstable_batchedUpdates:St}=gt;var bt={unstable_batchedUpdates:St};const{batchStart:wt}=ot,{unstable_batchedUpdates:Tt}=bt;let Rt=Tt;var At={getBatcher:()=>Rt,setBatcher:e=>{Rt=e},batchUpdates:e=>{Rt((()=>{let t=()=>{};try{t=wt(),e()}finally{t()}}))}};const{isSSR:Et}=mt,{batchUpdates:Nt}=At,{initializeNodeIfNewToStore:kt,peekNodeInfo:Vt}=Ie,{graph:Lt}=ve,{DEFAULT_VALUE:Mt,recoilValues:Ct,recoilValuesForKeys:Ut}=oe,{AbstractRecoilValue:Dt,getRecoilValueAsLoadable:Bt,setRecoilValue:xt,setUnvalidatedRecoilValue:It}=ot,{updateRetainCount:Ot}=vt,{getNextTreeStateVersion:Pt,makeEmptyStoreState:zt}=be;class Ft{constructor(e){l(this,"_store",void 0),l(this,"_refCount",0),l(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),Bt(this._store,e)))),l(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),l(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Ut(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?Ct.values():!0===e.isInitialized?Ut(yt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Re(Ct.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),l(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),Vt(this._store,this._store.getState().currentTree,e)))),l(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new Wt(this,Nt);return e(t),$t(t.getStore_INTERNAL())})),l(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new Wt(this,Nt);return await e(t),$t(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return u(n.get(t));const o=Lt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw i("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())kt(this._store,e.currentTree,t,"get"),Ot(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!I("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){I("recoil_memory_managament_2020")&&(Et||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){I("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){I("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function jt(e,t,n=!1){const o=e.getState(),r=n?Pt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function $t(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:u(n.previousTree);return new Ft(jt(e,o))}class Wt extends Ft{constructor(e,t){super(jt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),l(this,"_batch",void 0),l(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{Ot(n,e.key,1),xt(this.getStore_INTERNAL(),e,t)}))})),l(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{Ot(t,e.key,1),xt(this.getStore_INTERNAL(),e,Mt)}))})),l(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Nt((()=>{for(const[n,o]of e.entries())Ot(t,n,1),It(t,new Dt(n),o)}))})),this._batch=t}}var qt={Snapshot:Ft,MutableSnapshot:Wt,freshSnapshot:function(e){const t=new Ft(zt());return null!=e?t.map(e):t},cloneSnapshot:$t},Gt=qt.Snapshot,Ht=qt.MutableSnapshot,Kt=qt.freshSnapshot,Zt=qt.cloneSnapshot,Jt=Object.freeze({__proto__:null,Snapshot:Gt,MutableSnapshot:Ht,freshSnapshot:Kt,cloneSnapshot:Zt});const{getNextTreeStateVersion:Xt,makeEmptyStoreState:Qt}=be,{cleanUpNode:Yt,getDownstreamNodes:en,setNodeValue:tn,setUnvalidatedAtomValue_DEPRECATED:nn}=Ie,{graph:on}=ve,{cloneGraph:rn}=ve,{applyAtomValueWrites:an}=ot,{releaseScheduledRetainablesNow:sn}=vt,{freshSnapshot:cn}=Jt,{useCallback:un,useContext:ln,useEffect:dn,useMemo:fn,useRef:hn,useState:pn}=a;function vn(){throw i("This component must be used inside a <RecoilRoot> component.")}const yn=Object.freeze({getState:vn,replaceState:vn,getGraph:vn,subscribeToTransactions:vn,addTransactionMetadata:vn});let mn=!1;function _n(e){if(mn)throw i("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){I("recoil_memory_managament_2020")&&I("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&sn(e);const n=t.currentTree.version,o=Xt();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,rn(u(t.graphsByVersion.get(n))))}}const gn=a.createContext({current:yn}),Sn=()=>ln(gn),bn=a.createContext(null);function wn(e,t,n){const o=en(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function Tn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);I("recoil_early_rendering_2021")&&!t.suspendedComponentResolvers.size||(wn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Rn({setNotifyBatcherOfChange:e}){const t=Sn(),[n,o]=pn([]);return e((()=>o({}))),dn((()=>{re.enqueueExecution("Batcher",(()=>{!function(e){const t=e.current.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Tn(e.current),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):P("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,I("recoil_memory_managament_2020")&&sn(e.current)}finally{t.commitDepth--}}(t)}))})),dn((()=>()=>{e((()=>{}))}),[e]),null}let An=0;function En({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let s;const i=hn(null),c=un((e=>{i.current=e}),[i]),l=null!==(r=a.createMutableSource)&&void 0!==r?r:a.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=f.current.getState();_n(f.current);const n=u(t.nextTree);let o;try{mn=!0,o=e(n)}finally{mn=!1}o!==n&&(t.nextTree=o,I("recoil_early_rendering_2021")&&wn(d,t,o),u(i.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return u(t.get(e));const n=on();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=An++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=An++;return u(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{_n(f.current);for(const t of Object.keys(e))u(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=hn(d);s=hn(null!=e?function(e,t){const n=Qt();return t({set:(t,o)=>{const r=n.currentTree,a=tn(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:we(r.dirtyAtoms,s),atomValues:an(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=nn(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return cn().map(e).getStore_INTERNAL().getState()}(t):Qt());const h=fn((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return dn((()=>()=>{for(const e of f.current.getState().knownAtoms)Yt(f.current,e)}),[]),a.createElement(gn.Provider,{value:f},a.createElement(bn.Provider,{value:h},a.createElement(Rn,{setNotifyBatcherOfChange:c}),o))}var Nn={useStoreRef:Sn,useRecoilMutableSource:function(){const e=ln(bn);return null==e&&M("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,o=Sn();return!1===t&&o.current!==yn?e.children:a.createElement(En,n)},notifyComponents_FOR_TESTING:wn,sendEndOfBatchNotifications_FOR_TESTING:Tn};const{useRef:kn}=a;var Vn=function(){return kn(),"<component name not available>"};var Ln=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Mn,useRef:Cn}=a;var Un=function(e){const t=Cn();return Mn((()=>{t.current=e})),t.current};const{useStoreRef:Dn}=Nn,{SUSPENSE_TIMEOUT_MS:Bn}=vt,{updateRetainCount:xn}=vt,{RetentionZone:In}=Ee,{isSSR:On}=mt,{useEffect:Pn,useRef:zn}=a;var Fn=function(e){if(I("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof In?e:e.key)),n=Dn();Pn((()=>{if(!I("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!On)window.clearTimeout(o.current),o.current=null;else for(const n of t)xn(e,n,1);return()=>{for(const n of t)xn(e,n,-1)}}),[n,...t]);const o=zn(),r=Un(t);if(!On&&(void 0===r||!Ln(r,t))){const e=n.current;for(const n of t)xn(e,n,1);if(r)for(const t of r)xn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)xn(e,n,-1)}),Bn)}}(e)};const{batchUpdates:jn}=At,{DEFAULT_VALUE:$n}=oe,{useRecoilMutableSource:Wn,useStoreRef:qn}=Nn,{isRecoilValue:Gn}=K,{AbstractRecoilValue:Hn,getRecoilValueAsLoadable:Kn,setRecoilValue:Zn,setUnvalidatedRecoilValue:Jn,subscribeToRecoilValue:Xn}=ot,{setByAddingToSet:Qn}=Te,{mutableSourceExists:Yn,useMutableSource:eo}=U,{useCallback:to,useEffect:no,useMemo:oo,useRef:ro,useState:ao}=a;function so(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:i(`Invalid value of loadable atom "${t.key}"`)}function io(e){return I("recoil_memory_managament_2020")&&Fn(e),Yn()?function(e){const t=qn(),n=to((()=>{var n;const o=t.current,r=o.getState(),a=I("recoil_early_rendering_2021")&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return Kn(o,e,a)}),[t,e]),o=to((()=>n()),[n]),r=Vn(),a=to(((o,a)=>{const s=t.current;return Xn(s,e,(()=>{if(!I("recoil_suppress_rerender_in_callback"))return a();const e=n();c.current.is(e)||a(),c.current=e}),r).release}),[t,e,r,n]),s=Wn(),i=eo(s,o,a),c=ro(i);return no((()=>{c.current=i})),i}(e):function(e){const t=qn(),[n,o]=ao([]),r=Vn();no((()=>{const n=t.current,a=n.getState(),i=Xn(n,e,(t=>{var r;if(!I("recoil_suppress_rerender_in_callback"))return o([]);const a=Kn(n,e,n.getState().currentTree);(null===(r=s.current)||void 0===r?void 0:r.is(a))||o(a),s.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,o([])}));else{var c;if(!I("recoil_suppress_rerender_in_callback"))return o([]);const t=Kn(n,e,n.getState().currentTree);(null===(c=s.current)||void 0===c?void 0:c.is(t))||o(t),s.current=t}return i.release}),[r,e,t]);const a=Kn(t.current,e),s=ro(a);return no((()=>{s.current=a})),a}(e)}function co(e){const t=qn();return so(io(e),e,t)}function uo(e){const t=qn();return to((n=>{Zn(t.current,e,n)}),[t,e])}var lo={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=qn(),[,t]=ao([]),n=ro(new Set);n.current=new Set;const o=ro(new Set),r=ro(new Map),a=to((e=>{const t=r.current.get(e);t&&(t.release(),r.current.delete(e))}),[r]),s=Vn();return no((()=>{const i=e.current;function c(e,n){r.current.has(n)&&t([])}fe(n.current,o.current).forEach((e=>{if(r.current.has(e))return void M(`Double subscription to RecoilValue "${e}"`);const t=Xn(i,new Hn(e),(t=>{c(0,e)}),s);r.current.set(e,t);i.getState().nextTree?i.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{c(i.getState(),e)})):c(i.getState(),e)})),fe(o.current,n.current).forEach((e=>{a(e)})),o.current=n.current})),no((()=>{const e=r.current;return()=>e.forEach(((e,t)=>a(t)))}),[a]),oo((()=>{function t(t){return n=>{Zn(e.current,t,n)}}function o(t){var o;n.current.has(t.key)||(n.current=Qn(n.current,t.key));const r=e.current.getState();return Kn(e.current,t,I("recoil_early_rendering_2021")&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree)}function r(t){return so(o(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:o,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[o(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Zn(e.current,t,$n)}}}),[n,e])},useRecoilState:function(e){return[co(e),uo(e)]},useRecoilStateLoadable:function(e){return[io(e),uo(e)]},useRecoilValue:co,useRecoilValueLoadable:io,useResetRecoilState:function(e){const t=qn();return to((()=>{Zn(t.current,e,$n)}),[t,e])},useSetRecoilState:uo,useSetUnvalidatedAtomValues:function(){const e=qn();return(t,n={})=>{jn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Jn(e.current,new Hn(n),t)))}))}}};var fo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var ho=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var po=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:vo}=At,{DEFAULT_VALUE:yo,getNode:mo,nodes:_o}=oe,{useStoreRef:go}=Nn,{AbstractRecoilValue:So,setRecoilValueLoadable:bo}=ot,{SUSPENSE_TIMEOUT_MS:wo}=vt,{Snapshot:To,cloneSnapshot:Ro}=Jt,{isSSR:Ao}=mt,{useCallback:Eo,useEffect:No,useRef:ko,useState:Vo}=a;function Lo(e){const t=go();No((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Mo(e){const t=e.atomValues.toMap(),n=he(fo(t,((e,t)=>{const n=mo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return po(e.nonvalidatedAtoms.toMap(),n)}var Co={useRecoilSnapshot:function(){const e=go(),[t,n]=Vo((()=>Ro(e.current))),o=Un(t),r=ko();return No((()=>(r.current&&!Ao&&window.clearTimeout(r.current),t.retain())),[t]),Lo(Eo((e=>n(Ro(e))),[])),o===t||Ao||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),wo)),t},useGotoRecoilSnapshot:function(){const e=go();return Eo((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;vo((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&mo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{bo(e.current,new So(t),a.atomValues.has(t)?u(a.atomValues.get(t)):yo)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])},useRecoilTransactionObserver:function(e){Lo(Eo((t=>{const n=Ro(t,"current"),o=Ro(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){Lo(Eo((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(P("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Mo(o),a=Mo(n),s=he(_o,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=ho(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Lo};const{peekNodeInfo:Uo}=Ie,{useStoreRef:Do}=Nn;var Bo=function(){const e=Do();return({key:t})=>Uo(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:xo,useStoreRef:Io}=Nn,{useMemo:Oo}=a;var Po=function(){const e=Io().current;return Oo((()=>function({children:t}){return a.createElement(xo,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:zo}=V,{DEFAULT_VALUE:Fo,getNode:jo}=oe,{copyTreeState:$o,getRecoilValueAsLoadable:Wo,invalidateDownstreams:qo,writeLoadableToTreeState:Go}=ot;function Ho(e){return"atom"===jo(e.key).nodeType}class Ko{constructor(e,t){l(this,"_store",void 0),l(this,"_treeState",void 0),l(this,"_changes",void 0),l(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!Ho(e))throw i("Reading selectors within atomicUpdate is not supported");const t=Wo(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:i(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),l(this,"set",((e,t)=>{if(!Ho(e))throw i("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else this._changes.set(e.key,t)})),l(this,"reset",(e=>{this.set(e,Fo)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=$o(this._treeState);for(const[t,n]of this._changes)Go(e,t,zo(n));return qo(this._store,e),e}}var Zo=function(e){return t=>{e.replaceState((n=>{const o=new Ko(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Jo=Object.freeze({__proto__:null,atomicUpdater:Zo});var Xo=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Qo}=Jo,{batchUpdates:Yo}=At,{DEFAULT_VALUE:er}=oe,{useStoreRef:tr}=Nn,{setRecoilValue:nr}=ot,{Snapshot:or,cloneSnapshot:rr}=Jt,{useGotoRecoilSnapshot:ar}=Co,{useCallback:sr}=a;class ir{}const cr=new ir;var ur=function(e,t){const n=tr(),o=ar();return sr(((...t)=>{function r(e,t){nr(n.current,e,t)}function a(e){nr(n.current,e,er)}const s=rr(n.current),c=Qo(n.current);let u=cr;return Yo((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw i(n);const l=e({set:r,reset:a,snapshot:s,gotoSnapshot:o,transact_UNSTABLE:c});if("function"!==typeof l)throw i(n);u=l(...t)})),u instanceof ir&&Xo(!1),u}),null!=t?[...t,n]:void 0)};const{getNode:lr}=oe,{useStoreRef:dr}=Nn,{useCallback:fr}=a;var hr=function(e){const t=dr();return fr((()=>{var n;const o=t.current,{currentTree:r}=o.getState(),a=lr(e.key);null===(n=a.clearCache)||void 0===n||n.call(a,o,r)}),[e,t])};const{atomicUpdater:pr}=Jo,{useStoreRef:vr}=Nn,{useMemo:yr}=a;var mr=function(e,t){const n=vr();return yr((()=>(...t)=>{pr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const{isReactNative:_r,isSSR:gr}=mt;function Sr(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw i("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(c(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>Sr(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return Sr(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:Sr(n,t)]=r;return Sr(o,t,n)}return e instanceof Set?Sr(Array.from(e).sort(((e,n)=>Sr(e,t).localeCompare(Sr(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?Sr(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${Sr(n,t)}:${Sr(e[n],t,n)}`)).join(",")}}`}var br=function(e,t={allowFunctions:!1}){return Sr(e,t)};const wr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return wr(e.branches.get(r),t,n)},Tr=(e,t,n,o,r,a,s)=>{var i;let c;if(null==e)if(0===t.length)c={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,l]=e;c={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},c.branches.set(l,Tr(null,i,c,o,l,a,s))}else if(c=e,t.length){const[n,...r]=t,[i,u]=n;if("branch"!==e.type||e.nodeKey!==i)return P("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),c;e.branches.set(u,Tr(e.branches.get(u),r,e,o,u,a,s))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,c),c},Rr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Ar(e,n,n.parent)):e===t,Ar=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Ar(e,n,n.parent)):e===t,Er=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Er(t)),0);var Nr=class{constructor(e){var t,n,o;l(this,"_numLeafs",void 0),l(this,"_root",void 0),l(this,"_onHit",void 0),l(this,"_onSet",void 0),l(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return wr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=Tr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(u(o))}delete(e){if(!this.root())return!1;const t=u(this.root());return!!Rr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Er(e),!0))}clear(){this._numLeafs=0,this._root=null}},kr=Object.freeze({__proto__:null,TreeCache:Nr});var Vr=class{constructor(e){var t;l(this,"_maxSize",void 0),l(this,"_size",void 0),l(this,"_head",void 0),l(this,"_tail",void 0),l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=u(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Lr=Object.freeze({__proto__:null,LRUCache:Vr});const{LRUCache:Mr}=Lr,{TreeCache:Cr}=kr;var Ur=function(e,t=(e=>e)){const n=new Mr({maxSize:e}),o=new Cr({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:Dr}=kr,Br={equality:"reference",eviction:"keep-all",maxSize:1/0};var xr=function({equality:e=Br.equality,eviction:t=Br.eviction,maxSize:n=Br.maxSize}=Br){return function(e,t,n){switch(e){case"keep-all":return new Dr({mapNodeValue:n});case"lru":return Ur(u(t),n);case"most-recent":return Ur(1,n)}throw i(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>br(e)}throw i(`Unrecognized equality policy ${e}`)}(e))};var Ir={startPerfBlock:function(e){return()=>null}};const{loadableWithError:Or,loadableWithPromise:Pr,loadableWithValue:zr}=V,{getNodeLoadable:Fr,peekNodeLoadable:jr,setNodeValue:$r}=Ie,{saveDependencyMapToStore:Wr}=ve,{DEFAULT_VALUE:qr,RecoilValueNotReady:Gr,getConfigDeletionHandler:Hr,getNode:Kr,registerNode:Zr}=oe,{isRecoilValue:Jr}=K,{AbstractRecoilValue:Xr}=K,{markRecoilValueModified:Qr,setRecoilValueLoadable:Yr}=ot,{retainedByOptionWithDefault:ea}=vt,{cloneSnapshot:ta}=Jt,{startPerfBlock:na}=Ir;class oa{}const ra=new oa,aa=[],sa=new Map,ia=(()=>{let e=0;return()=>e++})();var ca=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=null!=e.set?e.set:void 0,s=new Set,l=xr(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=ea(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!I("recoil_memory_managament_2020")||h>0}function v(e){return f.has(e)||f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),u(f.get(e))}function y(e){return h++,e.getState().knownSelectors.add(n),()=>{h--,e.getState().knownSelectors.delete(n),f.delete(e)}}function m(){return void 0!==Hr(n)&&!p()}function _(e,t,n){if("loading"===t.state){let t=sa.get(n);null==t&&sa.set(n,t=new Set),t.add(e)}}function g(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return u(t.atomValues.get(n));const r=Fr(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function S(e,t,n,o,r,a){return t.then((o=>{if(!p())throw M(e,r),ra;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,zr(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=R(e,n);if(s&&"hasValue"===s.state)return V(s,e),s.contents;if(!C(e,r)){var i;const e=N(n);if("loading"===(null===e||void 0===e||null===(i=e.latestLoadable)||void 0===i?void 0:i.state))return e.latestLoadable.contents}const[c,u]=T(e,n,r);if(C(e,r)&&L(u,e,r),"loading"!==c.state&&(D(n,A(u),c),w(e,n,new Set(u.keys()),r),b(e,c,r)),"hasError"===c.state)throw c.contents;return c.contents})).catch((t=>{if(t instanceof oa)throw P("Selector was released while it had dependencies"),ra;if(!p())throw M(e,r),ra;const a=Or(t);throw U(t),D(n,A(o),Or(t)),w(e,n,new Set(o.keys()),r),b(e,a,r),t}))}function b(e,t,o){C(e,o)&&(V(t,e),function(e,t){const o=sa.get(t);if(void 0!==o){for(const t of o)Yr(t,new Xr(n),e);sa.delete(t)}}(t,o))}function w(e,t,o,r){var a,s,i,c,u,l,d;(C(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||t.version===(null===(i=e.getState())||void 0===i||null===(c=i.nextTree)||void 0===c?void 0:c.version))&&Wr(new Map([[n,o]]),e,null!==(u=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==u?u:e.getState().currentTree.version)}function T(e,t,r){const a=na(n);let s,u,l=!1;const d={loadingDepKey:null,loadingDepPromise:null},f=new Map,h=new Set;function v(n){const{key:o}=n;!function(e,t,n,o,r){n.add(o),w(e,t,n,r)}(e,t,h,o,r);const a=g(e,t,o);switch(f.set(o,a),a.state){case"hasValue":return a.contents;case"hasError":throw a.contents;case"loading":throw d.loadingDepKey=o,d.loadingDepPromise=a.contents,a.contents}throw i("Invalid Loadable state")}w(e,t,h,r);let y=!1;const m=t=>(...n)=>{if(!y)throw i("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=ta(e),r=t({snapshot:o});if("function"!==typeof r)throw i("getCallback() expects a function that returns a function.");return r(...n)};try{s=o({get:v,getCallback:m}),s=Jr(s)?v(s):s,y=!0,c(s)?s=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw M(e,r),ra;const a=zr(t);return U(t),D(n,A(o),a),w(e,n,new Set(o.keys()),r),b(e,a,r),t})).catch((t=>{if(!p())throw M(e,r),ra;if(C(e,r)&&L(o,e,r),c(t))return S(e,t,n,o,r,a);const s=Or(t);throw U(t),D(n,A(o),s),w(e,n,new Set(o.keys()),r),b(e,s,r),t}))}(e,s,t,f,r,d).finally(a):a()}catch(_){s=_,c(s)?s=S(e,s,t,f,r,d).finally(a):(l=!0,a())}return u=l?Or(s):c(s)?Pr(s):zr(s),"loading"!==u.state&&U(u.contents),[u,f]}function R(e,t){const o=new Set,r=v(e);let a;try{a=l.get((n=>{"string"!==typeof n&&Xo(!1);return g(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&"string"===typeof e.nodeKey&&(o.add(e.nodeKey),s.add(e.nodeKey))}})}catch(c){throw i(`Problem with cache lookup for selector "${n}": ${c.message}`)}return a&&w(e,t,o,r.latestExecutionId),a}function A(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function E(e,t){const n=ia(),[o,r]=T(e,t,n);return V(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&D(e,t,n)}(t,A(r),o),_(e,o,n),o}function N(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=v(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=k.get(t.version))&&void 0!==o?o:new Map).entries()),i=k.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||i)return!1;return k.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>g(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const k=new Map;function V(e,t,n,o,r){const a=v(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function L(e,t,n){const o=v(t);C(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function M(e,t){C(e,t)&&f.delete(e)}function C(e,t){return t===v(e).latestExecutionId}function U(e){0}function D(e,t,o){e.atomValues.set(n,o);try{l.set(t,o)}catch(r){throw i(`Problem with setting cache for selector "${n}": ${r.message}`)}}function B(e,t){return l.get((n=>{"string"!==typeof n&&Xo(!1);const o=jr(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function x(e,t){return function(e){if(aa.includes(n)){const e=`Recoil selector has circular dependencies: ${aa.slice(aa.indexOf(n)).join(" \u2192 ")}`;return Or(i(e))}aa.push(n);try{return e()}finally{aa.pop()}}((()=>function(e,t){const n=R(e,t);if(null!=n)return V(n,e),n;const o=N(t);if(o){const t=o;return _(e,u(t.latestLoadable),u(t.latestExecutionId)),u(t.latestLoadable)}return E(e,t)}(e,t)))}function O(e){e.atomValues.delete(n)}function z(e,n){null==t&&Xo(!1);for(const t of s){var o;const r=Kr(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}O(n),l.clear(),Qr(e,t)}if(null!=a){return t=Zr({key:n,nodeType:"selector",peek:B,get:x,set:(e,t,n)=>{let o=!1;const r=new Map;function s({key:n}){if(o)throw i("Recoil: Async selector sets are not currently supported.");const r=g(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new Gr(n):r.contents}function u(n,a){if(o)throw i("Recoil: Async selector sets are not currently supported.");const c="function"===typeof a?a(s(n)):a;$r(e,t,n.key,c).forEach(((e,t)=>r.set(t,e)))}const l=a({set:u,get:s,reset:function(e){u(e,qr)}},n);if(void 0!==l)throw c(l)?i("Recoil: Async selector sets are not currently supported."):i("Recoil: selector set should be a void function.");return o=!0,r},init:y,invalidate:O,clearCache:z,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=Zr({key:n,nodeType:"selector",peek:B,get:x,init:y,invalidate:O,clearCache:z,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:ua,loadableWithPromise:la,loadableWithValue:da}=V,{peekNodeInfo:fa}=Ie,{DEFAULT_VALUE:ha,DefaultValue:pa,getConfigDeletionHandler:va,registerNode:ya,setConfigDeletionHandler:ma}=oe,{isRecoilValue:_a}=K,{getRecoilValueAsLoadable:ga,markRecoilValueModified:Sa,setRecoilValue:ba,setRecoilValueLoadable:wa}=ot,{retainedByOptionWithDefault:Ta}=vt;function Ra(e){const{key:t,persistence_UNSTABLE:n}=e,o=Ta(e.retainedBy_UNSTABLE);let r,a=0,s=c(e.default)?la(e.default.then((e=>(s=da(e),e))).catch((e=>{throw s=ua(e),e}))):da(e.default);d(e.default);const l=new Map;function d(e){return e}const f=ya({key:t,nodeType:"atom",peek:function(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:s},get:function(e,o){if(o.atomValues.has(t))return u(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return M(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),s;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,ha),i=a instanceof pa?s:da(a);return r=i,r}return s},set:function(e,n,o){if(n.atomValues.has(t)){const e=u(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof pa)return new Map;return r=void 0,(new Map).set(t,da(o))},init:function(n,o,r){a++;const u=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===s.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Sa(n,f)};s.contents.then(e).catch(e)}let d=ha,h=null;if(null!=e.effects_UNSTABLE&&!u){let o=!0;function a(e){if(o&&e.key===t&&!(d instanceof pa)){const e=d;return e instanceof pa?s:c(e)?la(e.then((e=>e instanceof pa?s.toPromise():e))):da(e)}return ga(n,e)}function u(e){return a(e).toPromise()}function y(e){var r;const s=fa(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,e.key);return!o||e.key!==t||d instanceof pa?s:{...s,isSet:!0,loadable:a(e)}}const m=e=>t=>{if(o){const n=d instanceof pa||c(d)?"hasValue"===s.state?s.contents:ha:d;d="function"===typeof t?t(n):t,c(d)&&(d=d.then((t=>(h={effect:e,value:t},t))))}else{if(c(t))throw i("Setting atoms to async values is not implemented.");"function"!==typeof t&&(h={effect:e,value:t}),ba(n,f,"function"===typeof t?n=>{const o=t(n);return h={effect:e,value:o},o}:t)}},_=e=>()=>m(e)(ha),g=e=>o=>{n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:i}=n.getState();i||(P("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=a);const c=null!==(r=a.atomValues.get(t))&&void 0!==r?r:s;if("hasValue"===c.state){var u,l,d,f;const n=c.contents,r=null!==(u=i.atomValues.get(t))&&void 0!==u?u:s,p="hasValue"===r.state?r.contents:ha;(null===(l=h)||void 0===l?void 0:l.effect)!==e||(null===(d=h)||void 0===d?void 0:d.value)!==n?o(n,p,!a.atomValues.has(t)):(null===(f=h)||void 0===f?void 0:f.effect)===e&&(h=null)}}),t)};for(const t of null!==(p=e.effects_UNSTABLE)&&void 0!==p?p:[]){var p;const e=t({node:f,trigger:r,setSelf:m(t),resetSelf:_(t),onSet:g(t),getPromise:u,getLoadable:a,getInfo_UNSTABLE:y});var v;if(null!=e)l.set(n,[...null!==(v=l.get(n))&&void 0!==v?v:[],e])}o=!1}if(!(d instanceof pa)){var y;const e=d,r=c(e)?la(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&ba(e,f,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&wa(e,f,ua(n)),n}));return o}(n,e)):da(e);o.atomValues.set(t,r),null===(y=n.getState().nextTree)||void 0===y||y.atomValues.set(t,r)}return()=>{var e;a--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==va(t)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return f}function Aa(e){const{default:t,...n}=e;return _a(t)?function(e){const t=Aa({...e,default:ha,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof pa?t:u(e.persistence_UNSTABLE).validator(t,ha)},effects_UNSTABLE:e.effects_UNSTABLE}),n=ca({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof pa?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ma(n.key,va(e.key)),n}({...n,default:t}):Ra({...n,default:t})}var Ea=Aa;var Na=class{constructor(e){var t;l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},ka=Object.freeze({__proto__:null,MapCache:Na});const{LRUCache:Va}=Lr,{MapCache:La}=ka,Ma={equality:"reference",eviction:"none",maxSize:1/0};var Ca=function({equality:e=Ma.equality,eviction:t=Ma.eviction,maxSize:n=Ma.maxSize}=Ma){return function(e,t,n){switch(e){case"keep-all":return new La({mapKey:n});case"lru":return new Va({mapKey:n,maxSize:u(t)});case"most-recent":return new Va({mapKey:n,maxSize:1})}throw i(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>br(e)}throw i(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Ua}=oe;var Da=function(e){var t,n;const o=Ca({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...s}=e,i=Ea({...s,key:`${e.key}__${null!==(n=br(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return o.set(t,i),Ua(i.key,(()=>{o.delete(t)})),i}};const{setConfigDeletionHandler:Ba}=oe;let xa=0;var Ia=function(e){var t,n;const o=Ca({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=br(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${xa++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,c="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let u;if(null!=e.set){const n=e.set;u=ca({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c})}else u=ca({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c});return o.set(t,u),Ba(u.key,(()=>{o.delete(t)})),u}};const Oa=Ia({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Pa=function(e){return Oa(e)};const za=Ia({key:"__error",get:e=>()=>{throw i(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Fa=function(e){return za(e)};var ja=function(e){return e};const{loadableWithError:$a,loadableWithPromise:Wa,loadableWithValue:qa}=V;function Ga(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Ha(e){return null!=e&&!c(e)}function Ka(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Za(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Ja(e,t,n){return Za(e,n.map(((e,n)=>null==e?qa(t[n]):c(e)?Wa(e):$a(e))))}var Xa={waitForNone:Ia({key:"__waitForNone",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return Ja(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:Ia({key:"__waitForAny",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return r.some((e=>!c(e)))?Ja(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())c(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Ja(e,o,r))})).catch((a=>{r[n]=a,t(Ja(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Ia({key:"__waitForAll",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);if(r.every((e=>null==e)))return Za(e,o);const a=r.find(Ha);if(null!=a)throw a;return Promise.all(r).then((t=>{return Za(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:Ia({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ka(e),[o,r]=Ga(t,n);return r.every((e=>!c(e)))?Ja(e,o,r):Promise.all(r.map(((e,t)=>c(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Ja(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:Ia({key:"__noWait",get:e=>({get:t})=>{try{return qa(t(e))}catch(n){return c(n)?Wa(n):$a(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Qa}=V,{DefaultValue:Ya}=oe,{RecoilRoot:es}=Nn,{isRecoilValue:ts}=K,{retentionZone:ns}=Ee,{freshSnapshot:os}=Jt,{useRecoilState:rs,useRecoilStateLoadable:as,useRecoilValue:ss,useRecoilValueLoadable:is,useResetRecoilState:cs,useSetRecoilState:us,useSetUnvalidatedAtomValues:ls}=lo,{useGotoRecoilSnapshot:ds,useRecoilSnapshot:fs,useRecoilTransactionObserver:hs,useTransactionObservation_DEPRECATED:ps}=Co,{noWait:vs,waitForAll:ys,waitForAllSettled:ms,waitForAny:_s,waitForNone:gs}=Xa;var Ss={DefaultValue:Ya,isRecoilValue:ts,RecoilLoadable:Qa,RecoilRoot:es,useRecoilBridgeAcrossReactRoots_UNSTABLE:Po,atom:Ea,selector:ca,atomFamily:Da,selectorFamily:Ia,constSelector:Pa,errorSelector:Fa,readOnlySelector:ja,noWait:vs,waitForNone:gs,waitForAny:_s,waitForAll:ys,waitForAllSettled:ms,useRecoilValue:ss,useRecoilValueLoadable:is,useRecoilState:rs,useRecoilStateLoadable:as,useSetRecoilState:us,useResetRecoilState:cs,useGetRecoilValueInfo_UNSTABLE:Bo,useRecoilRefresher_UNSTABLE:hr,useRecoilCallback:ur,useRecoilTransaction_UNSTABLE:mr,useGotoRecoilSnapshot:ds,useRecoilSnapshot:fs,useRecoilTransactionObserver_UNSTABLE:hs,useTransactionObservation_UNSTABLE:ps,useSetUnvalidatedAtomValues_UNSTABLE:ls,snapshot_UNSTABLE:os,useRetain:Fn,retentionZone:ns},bs=Ss.RecoilRoot;n(4623);function ws(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Ts(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"===typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){ws(e,t,n[t])}))}return e}function Rs(e){var t=e.Component,n=e.pageProps;return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.default,{children:[(0,o.jsx)("title",{children:"National COVID-19 Chest Image Database (NCCID) | Documentation"}),(0,o.jsx)("link",{rel:"icon",href:"/favicon.ico"}),(0,o.jsx)("link",{href:"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap",rel:"stylesheet"})]}),(0,o.jsx)(bs,{children:(0,o.jsx)("div",{className:"antialiased",children:(0,o.jsx)(t,Ts({},n))})})]})}},4623:function(){},9008:function(e,t,n){e.exports=n(5443)}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(1780),t(387)}));var n=e.O();_N_E=n}]);