(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{1780:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(9681)}])},9681:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return ri}});var o=n(5893),r=n(9008),a=n(7294),s=n(3935);var i=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var c=function(e){return!!e&&"function"===typeof e.then};var u=function(e,t){if(null!=e)return e;throw i(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class d{getValue(){throw i("BaseLoadable")}toPromise(){throw i("BaseLoadable")}valueMaybe(){throw i("BaseLoadable")}valueOrThrow(){throw i(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw i("BaseLoadable")}promiseOrThrow(){throw i(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw i("BaseLoadable")}errorOrThrow(){throw i(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw i("BaseLoadable")}}class f extends d{constructor(e){super(),l(this,"state","hasValue"),l(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return c(t)?m(t):g(t)?t:v(t)}catch(t){return c(t)?m(t.next((()=>this.map(e)))):y(t)}}}class h extends d{constructor(e){super(),l(this,"state","hasError"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class p extends d{constructor(e){super(),l(this,"state","loading"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return m(this.contents.then((t=>{const n=e(t);if(g(n)){const e=n;switch(e.state){case"hasValue":case"loading":return e.contents;case"hasError":throw e.contents}}return n})).catch((t=>{if(c(t))return t.then((()=>this.map(e).contents));throw t})))}}function v(e){return Object.freeze(new f(e))}function y(e){return Object.freeze(new h(e))}function m(e){return Object.freeze(new p(e))}function _(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?v(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?y(u(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):m(Promise.all(e.map((e=>e.contents))))}((Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))).map((e=>g(e)?e:c(e)?m(e):v(e))));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function g(e){return e instanceof d}const S={of:e=>c(e)?m(e):g(e)?e:v(e),error:e=>y(e),all:_,isLoadable:g};var b={loadableWithValue:v,loadableWithError:y,loadableWithPromise:m,loadableLoading:function(){return Object.freeze(new p(new Promise((()=>{}))))},loadableAll:_,isLoadable:g,RecoilLoadable:S},T=b.loadableWithValue,w=b.loadableWithError,R=b.loadableWithPromise,A=b.loadableLoading,E=b.loadableAll,N=b.isLoadable,k=b.RecoilLoadable,V=Object.freeze({__proto__:null,loadableWithValue:T,loadableWithError:w,loadableWithPromise:R,loadableLoading:A,loadableAll:E,isLoadable:N,RecoilLoadable:k});class L{constructor(e){l(this,"key",void 0),this.key=e}}class M extends L{}class C extends L{}var U={AbstractRecoilValue:L,RecoilState:M,RecoilValueReadOnly:C,isRecoilValue:function(e){return e instanceof M||e instanceof C}},B=U.AbstractRecoilValue,D=U.RecoilState,O=U.RecoilValueReadOnly,I=U.isRecoilValue,x=Object.freeze({__proto__:null,AbstractRecoilValue:B,RecoilState:D,RecoilValueReadOnly:O,isRecoilValue:I});var P=function(e,...t){0};const z=(new Map).set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function F(e){var t;return null!==(t=z.get(e))&&void 0!==t&&t}F.setPass=e=>{z.set(e,!0)},F.setFail=e=>{z.set(e,!1)},F.clear=()=>{z.clear()};var j=F;var W=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var $=function(e,t,{error:n}={}){return null};class G{}const H=new G;class q extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const K=new Map,Z=new Map;class Y extends Error{}const J=new Map;function X(e){return J.get(e)}var Q={nodes:K,recoilValues:Z,registerNode:function(e){if(K.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}K.set(e.key,e);const t=null==e.set?new x.RecoilValueReadOnly(e.key):new x.RecoilState(e.key);return Z.set(e.key,t),t},getNode:function(e){const t=K.get(e);if(null==t)throw new Y(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return K.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!j("recoil_memory_managament_2020"))return;const n=K.get(e);var o;null!==n&&void 0!==n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(K.delete(e),null===(o=X(e))||void 0===o||o(),J.delete(e))},setConfigDeletionHandler:function(e,t){j("recoil_memory_managament_2020")&&(void 0===t?J.delete(e):J.set(e,t))},getConfigDeletionHandler:X,recoilValuesForKeys:function(e){return W(e,(e=>u(Z.get(e))))},NodeMissingError:Y,DefaultValue:G,DEFAULT_VALUE:H,RecoilValueNotReady:q};var ee={enqueueExecution:function(e,t){t()}};var te,ne,oe=(te=function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},c=function(e){return function(){return e}},u=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:w}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),c=l(n,a);return g(t,d(i)|d(c),i===c?[e(t,n+5,o,r,a,s)]:i<c?[r,s]:[s,r])},T=function(e,t){return e===t.edit},w=function(e,t,n,o,r,a,s){if(t(a,this.key)){var c=o(this.value);return c===this.value?this:c===i?(--s.value,v):T(e,this)?(this.value=c,this):m(e,r,a,c)}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var c=function(e,t,n,o,r,a,s,c){for(var u=r.length,l=0;l<u;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--c.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++c.value,h(e,u,m(t,o,s,y),r))}(T(e,this),e,t,this.hash,this.children,o,a,s);return c===this.children?this:c.length>1?_(e,this.hash,c):c[0]}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},A=function(e,t,n,o,r,s,i){var c=this.mask,u=this.children,m=l(n,r),_=d(m),b=f(c,_),w=c&_,R=w?u[b]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,N=T(e,this),k=c,V=void 0;if(w&&y(A)){if(!(k&=~_))return v;if(u.length<=2&&((E=u[1^b])===v||1===E.type||2===E.type))return u[1^b];V=p(N,b,u)}else if(w||y(A))V=h(N,b,A,u);else{if(u.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,c=0;s;++c)1&s&&(a[c]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,c,u);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,c=new Array(r+1);s<t;)c[i++]=o[s++];for(c[t]=n;s<r;)c[++i]=o[s++];return c}(N,b,A,u)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var c=this.size,u=this.children,d=l(n,r),f=u[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=T(e,this),_=void 0;if(y(f)&&!y(p))++c,_=h(m,d,p,u);else if(!y(f)&&y(p)){if(--c<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,c=o.length;i<c;++i)if(i!==n){var u=o[i];u&&!y(u)&&(r[a++]=u,s|=1<<i)}return g(e,s,r)}(e,c,d,u);_=h(m,d,v,u)}else _=h(m,d,p,u);return m?(this.size=c,this.children=_,this):S(e,c,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var c=o();return c===i?v:(++s.value,m(e,r,a,c))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,c=0,u=i.length;c<u;++c){var h=i[c];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||u},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var O=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return O(t,e,this)};var I=n.setHash=function(e,t,n,o){return D(c(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var x=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=c(i),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return j(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var $=n.mutate=function(e,t){var n=j(t);return e(n),W(n)};N.prototype.mutate=function(e){return $(e,this)};var G=function(e){return e&&H(e[0],e[1],e[2],e[3],e[4])},H=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return q(a,o,[e,t,n,o,r])}return G(r)},q=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return H(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var Y=function(e,t){return new Z(q(e._root,t))},J=function(e){return[e.key,e.value]},X=n.entries=function(e){return Y(e,J)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return Y(e,Q)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return Y(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var c=a[s++];c&&c.type&&(1===c.type?t=e(t,c.value,c.key):r.push(c.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n},te(ne={exports:{}},ne.exports),ne.exports);class re{constructor(e){l(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return se(this)}toMap(){return new Map(this._map)}}class ae{constructor(e){if(l(this,"_hamt",oe.empty.beginMutation()),e instanceof ae){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return se(this)}toMap(){return new Map(this._hamt)}}function se(e){return j("recoil_hamt_2020")?new ae(e):new re(e)}var ie=se,ce=Object.freeze({__proto__:null,persistentMap:ie});var ue=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var le=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function de(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:ue(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);u(r.get(e)).add(t)})),a){ue(a,e).forEach((e=>{if(!r.has(e))return;const n=u(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var fe={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),u(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:le(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:le(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=u(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&$("Tried to save dependencies to a discarded tree");const c=t.getGraph(n);if(de(e,c),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){de(e,t.getGraph(i.currentTree.version),c)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var u;const n=null===(u=i.nextTree)||void 0===u?void 0:u.version;if(void 0!==n){de(e,t.getGraph(n),c)}}}};let he=0;let pe=0;let ve=0;var ye={getNextTreeStateVersion:()=>he++,getNextStoreID:()=>pe++,getNextComponentID:()=>ve++};const{persistentMap:me}=ce,{graph:_e}=fe,{getNextTreeStateVersion:ge}=ye;function Se(){const e=ge();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:me(),nonvalidatedAtoms:me()}}var be={makeEmptyTreeState:Se,makeEmptyStoreState:function(){const e=Se();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,_e()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:ge};class Te{}var we={RetentionZone:Te,retentionZone:function(){return new Te}};var Re={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Ae=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var Ee=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};const{getNode:Ne,getNodeMaybe:ke,recoilValuesForKeys:Ve}=Q,{RetentionZone:Le}=we,{setByAddingToSet:Me}=Re,Ce=Object.freeze(new Set);class Ue extends Error{}function Be(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Ne(n),s=function(e,t,n){if(!j("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Le)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!j("recoil_memory_managament_2020"))return;const{retention:o}=e.getState();function r(e){const n=o.nodesRetainedByZone.get(e);null===n||void 0===n||n.delete(t),n&&0===n.size&&o.nodesRetainedByZone.delete(e)}if(n instanceof Le)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function De(e,t,n){return Ne(n).peek(e,t)}function Oe(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Ce;for(const t of e)o.has(t)||r.push(t)}return o}var Ie,xe,Pe,ze={getNodeLoadable:function(e,t,n){return Be(e,t,n,"get"),Ne(n).get(e,t)},peekNodeLoadable:De,setNodeValue:function(e,t,n,o){const r=Ne(n);if(null==r.set)throw new Ue(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Be(e,t,n,"set"),a(e,t,o)},initializeNode:function(e,t,n){Be(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=ke(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Me(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Ne(n).nodeType;return Ee({type:a},{loadable:()=>De(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return Ve(null!==(e=r.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:Ve(Ae(Oe(e,t,new Set([n])),(e=>e!==n))),components:W(null!==(r=null===(a=o.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}})},getDownstreamNodes:Oe};const Fe=null!==(Ie=a.createMutableSource)&&void 0!==Ie?Ie:a.unstable_createMutableSource,je=null!==(xe=a.useMutableSource)&&void 0!==xe?xe:a.unstable_useMutableSource,We=null!==(Pe=a.useSyncExternalStore)&&void 0!==Pe?Pe:a.unstable_useSyncExternalStore;var $e={createMutableSource:Fe,useMutableSource:je,useSyncExternalStore:We,reactMode:function(){return j("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:j("recoil_sync_external_store")&&null!=We?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:j("recoil_mutable_source")&&null!=je&&"undefined"!==typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?j("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:j("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}};const{getDownstreamNodes:Ge,getNodeLoadable:He,setNodeValue:qe}=ze,{getNextComponentID:Ke}=ye,{getNode:Ze,getNodeMaybe:Ye}=Q,{DefaultValue:Je,RecoilValueNotReady:Xe}=Q,{reactMode:Qe}=$e,{AbstractRecoilValue:et,RecoilState:tt,RecoilValueReadOnly:nt,isRecoilValue:ot}=x;function rt(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=He(e,t,n);if("loading"===r.state)throw new Xe(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=qe(e,t,o.key,a);for(const[e,n]of s.entries())at(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;at(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=Ye(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else $(`Unknown action ${n.type}`)}function at(e,t,n){"hasValue"===n.state&&n.contents instanceof Je?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function st(e,t){e.replaceState((n=>{const o=ut(n);for(const r of t)rt(e,o,r);return lt(e,o),o}))}function it(e,t){if(ct.length){const n=ct[ct.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else st(e,[t])}const ct=[];function ut(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function lt(e,t){const n=Ge(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=Ye(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function dt(e,t,n){it(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var ft={RecoilValueReadOnly:nt,AbstractRecoilValue:et,RecoilState:tt,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&$("Tried to read from a discarded tree");const s=He(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:dt,setRecoilValueLoadable:function(e,t,n){if(n instanceof Je)return dt(e,t,n);it(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){it(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){it(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=Ke(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),u(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]);const s=Qe();if(s.early&&("LEGACY"===s.mode||"MUTABLE_SOURCE"===s.mode)){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):$(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:ot,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Je?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return ct.push(e),()=>{for(const[t,n]of e)st(t,n);ct.pop()!==e&&$("Incorrect order of batch popping")}},writeLoadableToTreeState:at,invalidateDownstreams:lt,copyTreeState:ut,refreshRecoilValue:function(e,t){var n;const{currentTree:o}=e.getState(),r=Ze(t.key);null===(n=r.clearCache)||void 0===n||n.call(r,e,o)},invalidateDownstreams_FOR_TESTING:lt};var ht=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:pt}=ze,{deleteNodeConfigIfPossible:vt,getNode:yt}=Q,{RetentionZone:mt}=we,_t=new Set;function gt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void $("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof mt)for(const e of bt(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return i(t),a;function i(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],i=new Set;for(;n.size>0;)c(u(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(i.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);i.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===yt(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(Tt(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&ht(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:_t){var h;a.has(t)||f.add(t)}f.size&&i(f)}}(e,r);for(const s of a)St(e,o,s)}function St(e,t,n){if(!j("recoil_memory_managament_2020"))return;pt(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Tt(n);for(const c of r){var a;null===(a=o.retention.nodesRetainedByZone.get(c))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}vt(n)}function bt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:_t}function Tt(e){const t=yt(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof mt?[t]:t}function wt(e,t){if(!j("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):gt(e,new Set([t]))}(e,t)}var Rt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!j("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?wt(e,t):r.set(t,a)},updateRetainCountToZero:wt,releaseScheduledRetainablesNow:function(e){if(!j("recoil_memory_managament_2020"))return;const t=e.getState();gt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};const{unstable_batchedUpdates:At}=s;var Et={unstable_batchedUpdates:At};const{unstable_batchedUpdates:Nt}=Et;var kt={unstable_batchedUpdates:Nt};const{batchStart:Vt}=ft,{unstable_batchedUpdates:Lt}=kt;let Mt=Lt;var Ct={getBatcher:()=>Mt,setBatcher:e=>{Mt=e},batchUpdates:e=>{Mt((()=>{let t=()=>{};try{t=Vt(),e()}finally{t()}}))}};var Ut=function*(e){for(const t of e)for(const e of t)yield e};var Bt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};var Dt={memoizeWithArgsHash:function(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e.apply(this,o)),n[r]}},memoizeOneWithArgsHash:function(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,o;return[(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o},()=>{n=null}]}};const{batchUpdates:Ot}=Ct,{initializeNode:It,peekNodeInfo:xt}=ze,{graph:Pt}=fe,{getNextStoreID:zt}=ye,{DEFAULT_VALUE:Ft,recoilValues:jt,recoilValuesForKeys:Wt}=Q,{AbstractRecoilValue:$t,getRecoilValueAsLoadable:Gt,setRecoilValue:Ht,setUnvalidatedRecoilValue:qt}=ft,{updateRetainCount:Kt}=Rt,{getNextTreeStateVersion:Zt,makeEmptyStoreState:Yt}=be,{isSSR:Jt}=Bt,{memoizeOneWithArgsHashAndInvalidation:Xt}=Dt;class Qt{constructor(e){l(this,"_store",void 0),l(this,"_refCount",1),l(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),Gt(this._store,e)))),l(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),l(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Wt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?jt.values():!0===e.isInitialized?Wt(Ut([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Ae(jt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),l(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),xt(this._store,this._store.getState().currentTree,e)))),l(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new on(this,Ot);return e(t),t})),l(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new on(this,Ot);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t})),this._store={storeID:zt(),getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return u(n.get(t));const o=Pt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw i("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().knownAtoms)It(this._store,t,"get"),Kt(this._store,t,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&$("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){Jt||window.setTimeout((()=>this._release()),0)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((e=>e())),this._store.getState().nodeCleanupFunctions.clear(),!j("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){j("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function en(e,t,n=!1){const o=e.getState(),r=n?Zt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(W(o.nodeCleanupFunctions.entries(),(([e])=>[e,()=>{}])))}}const[tn,nn]=Xt(((e,t)=>{const n=e.getState(),o="current"===t?n.currentTree:u(n.previousTree);return new Qt(en(e,o))}),((e,t)=>{var n;return String(t)+String(e.storeID)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)}));class on extends Qt{constructor(e,t){super(en(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),l(this,"_batch",void 0),l(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{Kt(n,e.key,1),Ht(this.getStore_INTERNAL(),e,t)}))})),l(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{Kt(t,e.key,1),Ht(this.getStore_INTERNAL(),e,Ft)}))})),l(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Ot((()=>{for(const[n,o]of e.entries())Kt(t,n,1),qt(t,new $t(n),o)}))})),this._batch=t}}var rn={Snapshot:Qt,MutableSnapshot:on,freshSnapshot:function(e){const t=new Qt(Yt());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="current"){const n=tn(e,t);return n.isRetained()?n:(nn(),tn(e,t))}},an=rn.Snapshot,sn=rn.MutableSnapshot,cn=rn.freshSnapshot,un=rn.cloneSnapshot,ln=Object.freeze({__proto__:null,Snapshot:an,MutableSnapshot:sn,freshSnapshot:cn,cloneSnapshot:un});var dn=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};const{useRef:fn}=a;var hn=function(e){const t=fn(e);return t.current===e&&"function"===typeof e&&(t.current=e()),t};const{getNextTreeStateVersion:pn,makeEmptyStoreState:vn}=be,{cleanUpNode:yn,getDownstreamNodes:mn,initializeNode:_n,setNodeValue:gn,setUnvalidatedAtomValue_DEPRECATED:Sn}=ze,{graph:bn}=fe,{cloneGraph:Tn}=fe,{getNextStoreID:wn}=ye,{createMutableSource:Rn,reactMode:An}=$e,{applyAtomValueWrites:En}=ft,{releaseScheduledRetainablesNow:Nn}=Rt,{freshSnapshot:kn}=ln,{useCallback:Vn,useContext:Ln,useEffect:Mn,useMemo:Cn,useRef:Un,useState:Bn}=a;function Dn(){throw i("This component must be used inside a <RecoilRoot> component.")}const On=Object.freeze({storeID:wn(),getState:Dn,replaceState:Dn,getGraph:Dn,subscribeToTransactions:Dn,addTransactionMetadata:Dn});let In=!1;function xn(e){if(In)throw i("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){j("recoil_memory_managament_2020")&&j("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Nn(e);const n=t.currentTree.version,o=pn();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Tn(u(t.graphsByVersion.get(n))))}}const Pn=a.createContext({current:On}),zn=()=>Ln(Pn),Fn=a.createContext(null);function jn(e,t,n){const o=mn(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function Wn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);(!An().early||t.suspendedComponentResolvers.size>0)&&(jn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function $n({setNotifyBatcherOfChange:e}){const t=zn(),[,n]=Bn([]);return e((()=>n({}))),Mn((()=>(e((()=>n({}))),()=>{e((()=>{}))})),[e]),Mn((()=>{ee.enqueueExecution("Batcher",(()=>{!function(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Wn(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):$("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,j("recoil_memory_managament_2020")&&Nn(e)}finally{t.commitDepth--}}(t.current)}))})),null}let Gn=0;function Hn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const s=e=>{const t=r.current.graphsByVersion;if(t.has(e))return u(t.get(e));const n=bn();return t.set(e,n),n},i=(e,t)=>{if(null==t){const{transactionSubscriptions:t}=h.current.getState(),n=Gn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=h.current.getState();n.has(t)||n.set(t,new Map);const o=Gn++;return u(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},c=e=>{xn(h.current);for(const t of Object.keys(e))u(h.current.getState().nextTree).transactionMetadata[t]=e[t]},l=e=>{xn(h.current);const t=u(r.current.nextTree);let n;try{In=!0,n=e(t)}finally{In=!1}n!==t&&(r.current.nextTree=n,An().early&&jn(h.current,r.current,n),u(d.current)())},d=Un(null),f=Vn((e=>{d.current=e}),[d]),h=hn((()=>null!==n&&void 0!==n?n:{storeID:wn(),getState:()=>r.current,replaceState:l,getGraph:s,subscribeToTransactions:i,addTransactionMetadata:c}));null!=n&&(h.current=n),r=hn((()=>null!=e?function(e,t){const n=vn();return t({set:(t,o)=>{const r=n.currentTree,a=gn(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:dn(r.dirtyAtoms,s),atomValues:En(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=Sn(n.currentTree,t,e)}))}}),n}(h.current,e):null!=t?function(e){const t=kn().map(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach((e=>e())),n.nodeCleanupFunctions.clear(),n}(t):vn()));const p=Cn((()=>null===Rn||void 0===Rn?void 0:Rn(r,(()=>r.current.currentTree.version))),[r]);return Mn((()=>{const e=h.current;for(const t of new Set(e.getState().knownAtoms))_n(e,t,"get");return()=>{for(const t of e.getState().knownAtoms)yn(e,t)}}),[h]),a.createElement(Pn.Provider,{value:h},a.createElement(Fn.Provider,{value:p},a.createElement($n,{setNotifyBatcherOfChange:f}),o))}var qn={RecoilRoot:function(e){const{override:t,...n}=e,o=zn();return!1===t&&o.current!==On?e.children:a.createElement(Hn,n)},useStoreRef:zn,useRecoilMutableSource:function(){const e=Ln(Fn);return null==e&&P("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return zn().current.storeID},notifyComponents_FOR_TESTING:jn,sendEndOfBatchNotifications_FOR_TESTING:Wn};var Kn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Zn,useRef:Yn}=a;var Jn=function(e){const t=Yn();return Zn((()=>{t.current=e})),t.current};const{useStoreRef:Xn}=qn,{SUSPENSE_TIMEOUT_MS:Qn}=Rt,{updateRetainCount:eo}=Rt,{RetentionZone:to}=we,{useEffect:no,useRef:oo}=a,{isSSR:ro}=Bt;var ao=function(e){if(j("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof to?e:e.key)),n=Xn();no((()=>{if(!j("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!ro)window.clearTimeout(o.current),o.current=null;else for(const n of t)eo(e,n,1);return()=>{for(const n of t)eo(e,n,-1)}}),[n,...t]);const o=oo(),r=Jn(t);if(!ro&&(void 0===r||!Kn(r,t))){const e=n.current;for(const n of t)eo(e,n,1);if(r)for(const t of r)eo(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)eo(e,n,-1)}),Qn)}}(e)};const{useRef:so}=a;var io=function(){return so(),"<component name not available>"};const{batchUpdates:co}=Ct,{DEFAULT_VALUE:uo}=Q,{reactMode:lo,useMutableSource:fo,useSyncExternalStore:ho}=$e,{useRecoilMutableSource:po,useStoreRef:vo}=qn,{isRecoilValue:yo}=x,{AbstractRecoilValue:mo,getRecoilValueAsLoadable:_o,setRecoilValue:go,setUnvalidatedRecoilValue:So,subscribeToRecoilValue:bo}=ft,{useCallback:To,useEffect:wo,useMemo:Ro,useRef:Ao,useState:Eo}=a,{setByAddingToSet:No}=Re;function ko(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:i(`Invalid value of loadable atom "${t.key}"`)}function Vo(e){const t=vo(),n=io(),o=To((()=>{var n;const o=t.current,r=o.getState(),a=lo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return{loadable:_o(o,e,a),key:e.key}}),[t,e]),r=To((e=>{let t;return()=>{var n,o;const r=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(r.loadable)&&(null===(o=t)||void 0===o?void 0:o.key)===r.key?t:(t=r,r)}}),[]),a=Ro((()=>r(o)),[o,r]),s=To((o=>{const r=t.current;return bo(r,e,o,n).release}),[t,e,n]);return ho(s,a,a).loadable}function Lo(e){const t=vo(),n=To((()=>{var n;const o=t.current,r=o.getState(),a=lo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return _o(o,e,a)}),[t,e]),o=To((()=>n()),[n]),r=io(),a=To(((o,a)=>{const s=t.current;return bo(s,e,(()=>{if(!j("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),s=po();if(null==s)throw i("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const c=fo(s,o,a),u=Ao(c);return wo((()=>{u.current=c})),c}function Mo(e){const t=vo(),n=io(),o=To((()=>{var n;const o=t.current,r=o.getState(),a=lo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return _o(o,e,a)}),[t,e]),r=To((()=>({loadable:o(),key:e.key})),[o,e.key]),a=To((e=>{const t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t}),[r]);wo((()=>{const o=bo(t.current,e,(e=>{i(a)}),n);return i(a),o.release}),[n,e,t,a]);const[s,i]=Eo(r);return s.key!==e.key?r().loadable:s.loadable}function Co(e){const t=vo(),[,n]=Eo([]),o=io(),r=To((()=>{var n;const o=t.current,r=o.getState(),a=lo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return _o(o,e,a)}),[t,e]),a=r(),s=Ao(a);return wo((()=>{s.current=a})),wo((()=>{const a=t.current,i=a.getState(),c=bo(a,e,(e=>{var t;if(!j("recoil_suppress_rerender_in_callback"))return n([]);const o=r();null!==(t=s.current)&&void 0!==t&&t.is(o)||n(o),s.current=o}),o);if(i.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,n([])}));else{var u;if(!j("recoil_suppress_rerender_in_callback"))return n([]);const e=r();null!==(u=s.current)&&void 0!==u&&u.is(e)||n(e),s.current=e}return c.release}),[o,r,e,t]),a}function Uo(e){return j("recoil_memory_managament_2020")&&ao(e),{TRANSITION_SUPPORT:Mo,SYNC_EXTERNAL_STORE:Vo,MUTABLE_SOURCE:Lo,LEGACY:Co}[lo().mode](e)}function Bo(e){const t=vo();return ko(Uo(e),e,t)}function Do(e){const t=vo();return To((n=>{go(t.current,e,n)}),[t,e])}function Oo(e){return j("recoil_memory_managament_2020")&&ao(e),Mo(e)}function Io(e){const t=vo();return ko(Oo(e),e,t)}var xo={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=io(),t=vo(),[,n]=Eo([]),o=Ao(new Set);o.current=new Set;const r=Ao(new Set),a=Ao(new Map),s=To((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),i=To(((e,t)=>{a.current.has(t)&&n([])}),[]);return wo((()=>{const n=t.current;ue(o.current,r.current).forEach((t=>{if(a.current.has(t))return void P(`Double subscription to RecoilValue "${t}"`);const o=bo(n,new mo(t),(e=>i(e,t)),e);a.current.set(t,o);n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i(n.getState(),t)})):i(n.getState(),t)})),ue(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),wo((()=>{const n=a.current;return ue(o.current,new Set(n.keys())).forEach((o=>{const r=bo(t.current,new mo(o),(e=>i(e,o)),e);n.set(o,r)})),()=>n.forEach(((e,t)=>s(t)))}),[e,t,s,i]),Ro((()=>{function e(e){return n=>{go(t.current,e,n)}}function n(e){var n;o.current.has(e.key)||(o.current=No(o.current,e.key));const r=t.current.getState();return _o(t.current,e,lo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function r(e){return ko(n(e),e,t)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(t){return[r(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>go(t.current,e,uo)}}}),[o,t])},useRecoilState:function(e){return[Bo(e),Do(e)]},useRecoilStateLoadable:function(e){return[Uo(e),Do(e)]},useRecoilValue:Bo,useRecoilValueLoadable:Uo,useResetRecoilState:function(e){const t=vo();return To((()=>{go(t.current,e,uo)}),[t,e])},useSetRecoilState:Do,useSetUnvalidatedAtomValues:function(){const e=vo();return(t,n={})=>{co((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>So(e.current,new mo(n),t)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Oo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Io,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[Io(e),Do(e)]}};var Po=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var zo=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var Fo=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:jo}=Ct,{DEFAULT_VALUE:Wo,getNode:$o,nodes:Go}=Q,{useStoreRef:Ho}=qn,{AbstractRecoilValue:qo,setRecoilValueLoadable:Ko}=ft,{SUSPENSE_TIMEOUT_MS:Zo}=Rt,{cloneSnapshot:Yo}=ln,{useCallback:Jo,useEffect:Xo,useRef:Qo,useState:er}=a,{isSSR:tr}=Bt;function nr(e){const t=Ho();Xo((()=>t.current.subscribeToTransactions(e).release),[e,t])}function or(e){const t=e.atomValues.toMap(),n=le(Po(t,((e,t)=>{const n=$o(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return Fo(e.nonvalidatedAtoms.toMap(),n)}function rr(e,t){var n;const o=e.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;jo((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&$o(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Ko(e,new qo(t),a.atomValues.has(t)?u(a.atomValues.get(t)):Wo)})),e.replaceState((e=>({...e,stateID:t.getID()})))}))}var ar={useRecoilSnapshot:function(){const e=Ho(),[t,n]=er((()=>Yo(e.current))),o=Jn(t),r=Qo(),a=Qo();if(nr(Jo((e=>n(Yo(e))),[])),Xo((()=>{const e=t.retain();var n;r.current&&!tr&&(window.clearTimeout(r.current),r.current=null,null===(n=a.current)||void 0===n||n.call(a),a.current=null);return e}),[t]),o!==t&&!tr){var s;if(r.current)window.clearTimeout(r.current),r.current=null,null===(s=a.current)||void 0===s||s.call(a),a.current=null;a.current=t.retain(),r.current=window.setTimeout((()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null}),Zo)}return t},gotoSnapshot:rr,useGotoRecoilSnapshot:function(){const e=Ho();return Jo((t=>rr(e.current,t)),[e])},useRecoilTransactionObserver:function(e){nr(Jo((t=>{const n=Yo(t,"current"),o=Yo(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){nr(Jo((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||($("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=or(o),a=or(n),s=le(Go,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=zo(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:nr};const{peekNodeInfo:sr}=ze,{useStoreRef:ir}=qn;var cr=function(){const e=ir();return({key:t})=>sr(e.current,e.current.getState().currentTree,t)};const{reactMode:ur}=$e,{RecoilRoot:lr,useStoreRef:dr}=qn,{useMemo:fr}=a;var hr=function(){"MUTABLE_SOURCE"===ur().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=dr().current;return fr((()=>function({children:t}){return a.createElement(lr,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:pr}=V,{initializeNode:vr}=ze,{DEFAULT_VALUE:yr,getNode:mr}=Q,{copyTreeState:_r,getRecoilValueAsLoadable:gr,invalidateDownstreams:Sr,writeLoadableToTreeState:br}=ft;function Tr(e){return"atom"===mr(e.key).nodeType}class wr{constructor(e,t){l(this,"_store",void 0),l(this,"_treeState",void 0),l(this,"_changes",void 0),l(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!Tr(e))throw i("Reading selectors within atomicUpdate is not supported");const t=gr(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:i(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),l(this,"set",((e,t)=>{if(!Tr(e))throw i("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else vr(this._store,e.key,"set"),this._changes.set(e.key,t)})),l(this,"reset",(e=>{this.set(e,yr)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=_r(this._treeState);for(const[t,n]of this._changes)br(e,t,pr(n));return Sr(this._store,e),e}}var Rr=function(e){return t=>{e.replaceState((n=>{const o=new wr(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Ar=Rr,Er=Object.freeze({__proto__:null,atomicUpdater:Ar});var Nr=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:kr}=Er,{batchUpdates:Vr}=Ct,{DEFAULT_VALUE:Lr}=Q,{useStoreRef:Mr}=qn,{refreshRecoilValue:Cr,setRecoilValue:Ur}=ft,{Snapshot:Br,cloneSnapshot:Dr}=ln,{gotoSnapshot:Or}=ar,{useCallback:Ir}=a;class xr{}const Pr=new xr;function zr(e,t,n,o){let r=Pr;return Vr((()=>{const a="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof t)throw i(a);const s=Ee({...null!==o&&void 0!==o?o:{},set:(t,n)=>Ur(e,t,n),reset:t=>Ur(e,t,Lr),refresh:t=>Cr(e,t),gotoSnapshot:t=>Or(e,t),transact_UNSTABLE:t=>kr(e)(t)},{snapshot:()=>Dr(e)}),c=t(s);if("function"!==typeof c)throw i(a);r=c(...n)})),r instanceof xr&&Nr(!1),r}var Fr={recoilCallback:zr,useRecoilCallback:function(e,t){const n=Mr();return Ir(((...t)=>zr(n.current,e,t)),null!=t?[...t,n]:void 0)}};const{useStoreRef:jr}=qn,{refreshRecoilValue:Wr}=ft,{useCallback:$r}=a;var Gr=function(e){const t=jr();return $r((()=>{const n=t.current;Wr(n,e)}),[e,t])};const{atomicUpdater:Hr}=Er,{useStoreRef:qr}=qn,{useMemo:Kr}=a;var Zr=function(e,t){const n=qr();return Kr((()=>(...t)=>{Hr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const Yr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Yr(e.branches.get(r),t,n)},Jr=(e,t,n,o,r,a,s)=>{var i;let c;if(null==e)if(0===t.length)c={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,l]=e;c={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},c.branches.set(l,Jr(null,i,c,o,l,a,s))}else if(c=e,t.length){const[n,...r]=t,[i,u]=n;if("branch"!==e.type||e.nodeKey!==i)return $("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),c;e.branches.set(u,Jr(e.branches.get(u),r,e,o,u,a,s))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,c),c},Xr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Qr(e,n,n.parent)):e===t,Qr=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Qr(e,n,n.parent)):e===t,ea=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+ea(t)),0);var ta=class{constructor(e){var t,n,o;l(this,"_numLeafs",void 0),l(this,"_root",void 0),l(this,"_onHit",void 0),l(this,"_onSet",void 0),l(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Yr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=Jr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(u(o))}delete(e){if(!this.root())return!1;const t=u(this.root());return!!Xr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=ea(e),!0))}clear(){this._numLeafs=0,this._root=null}},na=Object.freeze({__proto__:null,TreeCache:ta});var oa=class{constructor(e){var t;l(this,"_maxSize",void 0),l(this,"_size",void 0),l(this,"_head",void 0),l(this,"_tail",void 0),l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=u(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},ra=oa,aa=Object.freeze({__proto__:null,LRUCache:ra});const{LRUCache:sa}=aa,{TreeCache:ia}=na;var ca=function(e,t=(e=>e)){const n=new sa({maxSize:e}),o=new ia({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};function ua(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw i("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(c(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>ua(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return ua(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:ua(n,t)]=r;return ua(o,t,n)}return e instanceof Set?ua(Array.from(e).sort(((e,n)=>ua(e,t).localeCompare(ua(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?ua(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${ua(n,t)}:${ua(e[n],t,n)}`)).join(",")}}`}var la=function(e,t={allowFunctions:!1}){return ua(e,t)};const{TreeCache:da}=na,fa={equality:"reference",eviction:"keep-all",maxSize:1/0};var ha=function({equality:e=fa.equality,eviction:t=fa.eviction,maxSize:n=fa.maxSize}=fa){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>la(e)}throw i(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new da({mapNodeValue:n});case"lru":return ca(u(t),n);case"most-recent":return ca(1,n)}throw i(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};const{isReactNative:pa,isSSR:va}=Bt;var ya={startPerfBlock:function(e){return()=>null}};const{loadableWithError:ma,loadableWithPromise:_a,loadableWithValue:ga}=V,{getNodeLoadable:Sa,peekNodeLoadable:ba,setNodeValue:Ta}=ze,{saveDependencyMapToStore:wa}=fe,{DEFAULT_VALUE:Ra,RecoilValueNotReady:Aa,getConfigDeletionHandler:Ea,getNode:Na,registerNode:ka}=Q,{isRecoilValue:Va}=x,{markRecoilValueModified:La}=ft,{retainedByOptionWithDefault:Ma}=Rt,{recoilCallback:Ca}=Fr,{startPerfBlock:Ua}=ya;class Ba{}const Da=new Ba,Oa=[],Ia=new Map,xa=(()=>{let e=0;return()=>e++})();var Pa=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=null!=e.set?e.set:void 0,s=new Set,l=ha(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=Ma(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!j("recoil_memory_managament_2020")||h>0}function v(e){return e.getState().knownSelectors.add(n),h++,()=>{h--}}function y(){return void 0!==Ea(n)&&!p()}function m(e,t,n,o,r){C(t,o,r),T(e,t,new Set(r.keys()),n),_(e,n)}function _(e,n){M(e,n)&&L(e);const o=Ia.get(n);if(void 0!==o){for(const e of o)La(e,u(t));Ia.delete(n)}}function g(e,t){let n=Ia.get(t);null==n&&Ia.set(t,n=new Set),n.add(e)}function S(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return u(t.atomValues.get(n));const r=Sa(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function b(e,t,n,o,r,a){return t.then((o=>{if(!p())throw L(e),Da;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,ga(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=R(e,n);if(s&&"loading"!==s.state){if((M(e,r)||null==k(e))&&_(e,r),"hasValue"===s.state)return s.contents;throw s.contents}if(!M(e,r)){const e=E(n);if("loading"===(null===e||void 0===e?void 0:e.latestLoadable.state))return e.latestLoadable.contents}const[i,c]=w(e,n,r);if(V(e,r,c),"loading"!==i.state&&m(e,n,r,i,c),"hasError"===i.state)throw i.contents;return i.contents})).catch((t=>{if(t instanceof Ba)throw Da;if(!p())throw L(e),Da;const a=ma(t);throw m(e,n,r,a,o),t}))}function T(e,t,o,r){var a,i,c,u,l,d,f;(M(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||t.version===(null===(c=e.getState())||void 0===c||null===(u=c.nextTree)||void 0===u?void 0:u.version))&&(wa(new Map([[n,o]]),e,null!==(l=null===(d=e.getState())||void 0===d||null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==l?l:e.getState().currentTree.version),o.forEach((e=>s.add(e))))}function w(e,r,a){const s=Ua(n);let u=!0;const l=()=>{s(),u=!1};let d,f,h=!1;const v={loadingDepKey:null,loadingDepPromise:null},y=new Map,_=new Set;function g(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),T(e,t,n,r)}(e,r,_,n,a);const o=S(e,r,n);switch(y.set(n,o),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw v.loadingDepKey=n,v.loadingDepPromise=o.contents,o.contents}throw i("Invalid Loadable state")}T(e,r,_,a);const w=n=>(...o)=>{if(u)throw i("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==t&&Nr(!1),Ca(e,n,o,{node:t})};try{d=o({get:g,getCallback:w}),d=Va(d)?g(d):d,c(d)?d=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw L(e),Da;const a=ga(t);return m(e,n,r,a,o),t})).catch((t=>{if(!p())throw L(e),Da;if(V(e,r,o),c(t))return b(e,t,n,o,r,a);const s=ma(t);throw m(e,n,r,s,o),t}))}(e,d,r,y,a,v).finally(l):l()}catch(R){d=R,c(d)?d=b(e,d,r,y,a,v).finally(l):(h=!0,l())}return f=h?ma(d):c(d)?_a(d):ga(d),[f,y]}function R(e,t){const o=new Set,r=k(e);let a;try{a=l.get((n=>{"string"!==typeof n&&Nr(!1);return S(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(s){throw i(`Problem with cache lookup for selector "${n}": ${s.message}`)}return a&&T(e,t,o,null===r||void 0===r?void 0:r.latestExecutionId),a}function A(e,t){const n=xa(),[o,r]=w(e,t,n);return"loading"===o.state?(!function(e,t,n,o,r){f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:o,latestExecutionId:t,latestLoadable:n,stateVersion:r.version})}(e,n,o,r,t),g(e,n)):(L(e),C(t,o,r)),o}function E(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=k(e),a=null!==(n=null===r||void 0===r?void 0:r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=N.get(t.version))&&void 0!==o?o:new Map).entries()),i=N.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===(null===r||void 0===r?void 0:r.stateVersion)||i)return!1;return N.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>S(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const N=new Map;function k(e){return f.get(e)}function V(e,t,n){if(M(e,t)){const t=k(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function L(e){f.delete(e)}function M(e,t){var n;return t===(null===(n=k(e))||void 0===n?void 0:n.latestExecutionId)}function C(e,t,o){e.atomValues.set(n,t);try{l.set(function(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}(o),t)}catch(r){throw i(`Problem with setting cache for selector "${n}": ${r.message}`)}}function U(e,t){return l.get((n=>{var o;return"string"!==typeof n&&Nr(!1),null===(o=ba(e,t,n))||void 0===o?void 0:o.contents}))}function B(e,t){return function(e){if(Oa.includes(n)){const e=`Recoil selector has circular dependencies: ${Oa.slice(Oa.indexOf(n)).join(" \u2192 ")}`;return ma(i(e))}Oa.push(n);try{return e()}finally{Oa.pop()}}((()=>function(e,t){const n=R(e,t);if(null!=n)return L(e),n;const o=E(t);var r;return null!=o?("loading"===(null===(r=o.latestLoadable)||void 0===r?void 0:r.state)&&g(e,u(o.latestExecutionId)),u(o.latestLoadable)):A(e,t)}(e,t)))}function D(e){e.atomValues.delete(n)}function O(e,n){null==t&&Nr(!1);for(const t of s){var o;const r=Na(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}s.clear(),D(n),l.clear(),La(e,t)}if(null!=a){return t=ka({key:n,nodeType:"selector",peek:U,get:B,set:(e,t,n)=>{let o=!1;const r=new Map;function s({key:n}){if(o)throw i("Recoil: Async selector sets are not currently supported.");const r=S(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new Aa(n):r.contents}function u(n,a){if(o)throw i("Recoil: Async selector sets are not currently supported.");const c="function"===typeof a?a(s(n)):a;Ta(e,t,n.key,c).forEach(((e,t)=>r.set(t,e)))}const l=a({set:u,get:s,reset:function(e){u(e,Ra)}},n);if(void 0!==l)throw c(l)?i("Recoil: Async selector sets are not currently supported."):i("Recoil: selector set should be a void function.");return o=!0,r},init:v,invalidate:D,clearCache:O,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=ka({key:n,nodeType:"selector",peek:U,get:B,init:v,invalidate:D,clearCache:O,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:za,loadableWithPromise:Fa,loadableWithValue:ja}=V,{peekNodeInfo:Wa}=ze,{DEFAULT_VALUE:$a,DefaultValue:Ga,getConfigDeletionHandler:Ha,registerNode:qa,setConfigDeletionHandler:Ka}=Q,{isRecoilValue:Za}=x,{getRecoilValueAsLoadable:Ya,markRecoilValueModified:Ja,setRecoilValue:Xa,setRecoilValueLoadable:Qa}=ft,{retainedByOptionWithDefault:es}=Rt;function ts(e){const{key:t,persistence_UNSTABLE:n}=e,o=es(e.retainedBy_UNSTABLE);let r,a=0,s=c(e.default)?Fa(e.default.then((e=>(s=ja(e),e))).catch((e=>{throw s=za(e),e}))):ja(e.default);d(e.default);const l=new Map;function d(e){return e}function f(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:s}const h=qa({key:t,nodeType:"atom",peek:f,get:function(e,o){if(o.atomValues.has(t))return u(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return P(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),s;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,$a),i=a instanceof Ga?s:ja(a);return r=i,r}return s},set:function(e,n,o){if(n.atomValues.has(t)){const e=u(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof Ga)return new Map;return r=void 0,(new Map).set(t,ja(o))},init:function(n,o,r){var u;if(a++,n.getState().knownAtoms.add(t),"loading"===s.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Ja(n,h)};s.contents.finally(e)}const d=null!==(u=e.effects)&&void 0!==u?u:e.effects_UNSTABLE;if(null!=d){let e=!0,a=$a,u=!1,m=null;function _(r){if(e&&r.key===t){const e=a;return e instanceof Ga?f(n,o):c(e)?Fa(e.then((e=>e instanceof Ga?s.toPromise():e))):ja(e)}return Ya(n,r)}function g(e){return _(e).toPromise()}function S(o){var r;const s=Wa(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,o.key);return!e||o.key!==t||a instanceof Ga?s:{...s,isSet:!0,loadable:_(o)}}const b=t=>o=>{if(e){const e=_(h),n="hasValue"===e.state?e.contents:$a;a="function"===typeof o?o(n):o,c(a)&&(a=a.then((e=>(m={effect:t,value:e},e))))}else{if(c(o))throw i("Setting atoms to async values is not implemented.");"function"!==typeof o&&(m={effect:t,value:o}),Xa(n,h,"function"===typeof o?e=>{const n=o(e);return m={effect:t,value:n},n}:o)}},T=e=>()=>b(e)($a),w=e=>o=>{var r;const{release:a}=n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:i}=n.getState();i||($("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=a);const c=null!==(r=a.atomValues.get(t))&&void 0!==r?r:s;if("hasValue"===c.state){var u,l,d,f;const n=c.contents,r=null!==(u=i.atomValues.get(t))&&void 0!==u?u:s,h="hasValue"===r.state?r.contents:$a;(null===(l=m)||void 0===l?void 0:l.effect)!==e||(null===(d=m)||void 0===d?void 0:d.value)!==n?o(n,h,!a.atomValues.has(t)):(null===(f=m)||void 0===f?void 0:f.effect)===e&&(m=null)}}),t);l.set(n,[...null!==(r=l.get(n))&&void 0!==r?r:[],a])};for(const t of d)try{const e=t({node:h,storeID:n.storeID,trigger:r,setSelf:b(t),resetSelf:T(t),onSet:w(t),getPromise:g,getLoadable:_,getInfo_UNSTABLE:S});var p;if(null!=e)l.set(n,[...null!==(p=l.get(n))&&void 0!==p?p:[],e])}catch(y){a=y,u=!0}if(e=!1,!(a instanceof Ga)){var v;const e=a,r=u?za(a):c(e)?Fa(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Xa(e,h,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Qa(e,h,za(n)),n}));return o}(n,e)):ja(e);o.atomValues.set(t,r),null===(v=n.getState().nextTree)||void 0===v||v.atomValues.set(t,r)}}return()=>{var e;a--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==Ha(t)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return h}function ns(e){const{default:t,...n}=e;return Za(t)?function(e){const t=ns({...e,default:$a,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof Ga?t:u(e.persistence_UNSTABLE).validator(t,$a)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=Pa({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof Ga?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Ka(n.key,Ha(e.key)),n}({...n,default:t}):ts({...n,default:t})}var os=ns;var rs=class{constructor(e){var t;l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},as=Object.freeze({__proto__:null,MapCache:rs});const{LRUCache:ss}=aa,{MapCache:is}=as,cs={equality:"reference",eviction:"none",maxSize:1/0};var us=function({equality:e=cs.equality,eviction:t=cs.eviction,maxSize:n=cs.maxSize}=cs){const o=function(e){switch(e){case"reference":return e=>e;case"value":return e=>la(e)}throw i(`Unrecognized equality policy ${e}`)}(e),r=function(e,t,n){switch(e){case"keep-all":return new is({mapKey:n});case"lru":return new ss({mapKey:n,maxSize:u(t)});case"most-recent":return new ss({mapKey:n,maxSize:1})}throw i(`Unrecognized eviction policy ${e}`)}(t,n,o);return r};const{setConfigDeletionHandler:ls}=Q;var ds=function(e){var t,n;const o=us({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n,r;const a=o.get(t);if(null!=a)return a;const{cachePolicyForParams_UNSTABLE:s,...i}=e,c=os({...i,key:`${e.key}__${null!==(n=la(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"===typeof e.effects?e.effects(t):"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return o.set(t,c),ls(c.key,(()=>{o.delete(t)})),c}};const{setConfigDeletionHandler:fs}=Q;let hs=0;var ps=function(e){var t,n;const o=us({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=la(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${hs++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,c="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let u;if(null!=e.set){const n=e.set;u=Pa({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c})}else u=Pa({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c});return o.set(t,u),fs(u.key,(()=>{o.delete(t)})),u}};const vs=ps({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var ys=function(e){return vs(e)};const ms=ps({key:"__error",get:e=>()=>{throw i(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var _s=function(e){return ms(e)};var gs=function(e){return e};const{loadableWithError:Ss,loadableWithPromise:bs,loadableWithValue:Ts}=V;function ws(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Rs(e){return null!=e&&!c(e)}function As(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Es(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Ns(e,t,n){return Es(e,n.map(((e,n)=>null==e?Ts(t[n]):c(e)?bs(e):Ss(e))))}var ks={waitForNone:ps({key:"__waitForNone",get:e=>({get:t})=>{const n=As(e),[o,r]=ws(t,n);return Ns(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:ps({key:"__waitForAny",get:e=>({get:t})=>{const n=As(e),[o,r]=ws(t,n);return r.some((e=>!c(e)))?Ns(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())c(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Ns(e,o,r))})).catch((a=>{r[n]=a,t(Ns(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:ps({key:"__waitForAll",get:e=>({get:t})=>{const n=As(e),[o,r]=ws(t,n);if(r.every((e=>null==e)))return Es(e,o);const a=r.find(Rs);if(null!=a)throw a;return Promise.all(r).then((t=>{return Es(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:ps({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=As(e),[o,r]=ws(t,n);return r.every((e=>!c(e)))?Ns(e,o,r):Promise.all(r.map(((e,t)=>c(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Ns(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:ps({key:"__noWait",get:e=>({get:t})=>{try{return Ts(t(e))}catch(n){return c(n)?bs(n):Ss(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Vs}=V,{DefaultValue:Ls}=Q,{RecoilRoot:Ms,useRecoilStoreID:Cs}=qn,{isRecoilValue:Us}=x,{retentionZone:Bs}=we,{freshSnapshot:Ds}=ln,{useRecoilState:Os,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Is,useRecoilStateLoadable:xs,useRecoilValue:Ps,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:zs,useRecoilValueLoadable:Fs,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:js,useResetRecoilState:Ws,useSetRecoilState:$s}=xo,{useGotoRecoilSnapshot:Gs,useRecoilSnapshot:Hs,useRecoilTransactionObserver:qs}=ar,{useRecoilCallback:Ks}=Fr,{noWait:Zs,waitForAll:Ys,waitForAllSettled:Js,waitForAny:Xs,waitForNone:Qs}=ks;var ei={DefaultValue:Ls,isRecoilValue:Us,RecoilLoadable:Vs,RecoilRoot:Ms,useRecoilStoreID:Cs,useRecoilBridgeAcrossReactRoots_UNSTABLE:hr,atom:os,selector:Pa,atomFamily:ds,selectorFamily:ps,constSelector:ys,errorSelector:_s,readOnlySelector:gs,noWait:Zs,waitForNone:Qs,waitForAny:Xs,waitForAll:Ys,waitForAllSettled:Js,useRecoilValue:Ps,useRecoilValueLoadable:Fs,useRecoilState:Os,useRecoilStateLoadable:xs,useSetRecoilState:$s,useResetRecoilState:Ws,useGetRecoilValueInfo_UNSTABLE:cr,useRecoilRefresher_UNSTABLE:Gr,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:js,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:zs,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Is,useRecoilCallback:Ks,useRecoilTransaction_UNSTABLE:Zr,useGotoRecoilSnapshot:Gs,useRecoilSnapshot:Hs,useRecoilTransactionObserver_UNSTABLE:qs,snapshot_UNSTABLE:Ds,useRetain:ao,retentionZone:Bs},ti=ei.RecoilRoot;n(3154);function ni(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function oi(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"===typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){ni(e,t,n[t])}))}return e}function ri(e){var t=e.Component,n=e.pageProps;return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.default,{children:[(0,o.jsx)("title",{children:"National COVID-19 Chest Image Database (NCCID) | Documentation"}),(0,o.jsx)("link",{rel:"icon",href:"/favicon.ico"}),(0,o.jsx)("link",{href:"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap",rel:"stylesheet"})]}),(0,o.jsx)(ti,{children:(0,o.jsx)("div",{className:"antialiased",children:(0,o.jsx)(t,oi({},n))})})]})}},3154:function(){},9008:function(e,t,n){e.exports=n(3121)}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(1780),t(880)}));var n=e.O();_N_E=n}]);